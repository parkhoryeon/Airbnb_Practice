# 가상환경 
  python -m venv [가상환경 이름]
  [가상환경 이름]/Scripts/activate - 활성화
  deactivate - 비활성화

# 장고설치
  pip install django

# 장고 프로젝트 생성
  django-admin startproject config . (해당 위치에 manage.py 설정)

# 장고 슈퍼계정 생성
  python manage.py createsuperuser

# 장고 DB 마이그레이션
  python manage.py makemigrations
  python manage.py migrate

# 장고 App 생성
  python manage.py startapp [앱이름]

# 앱을 생성하면 settings.py 에 INSTALLED_APPS 에 추가해줘야 한다.

# INSTALLED_APPS = SYSTEM_APPS + THIRD_PARTY_APPS + CUSTOM_APPS
  3가지로 나누어서 관리하면 구분하기 쉽다.

# TEMPLATES와 STATIC 설정

# 장고 기본 User모델이 아닌 커스텀 User 모델을 만드려면
  from django.contrib.auth.models import AbstractUser
  모델 Class에 AbstractUser를 상속 받아야 한다.

# 추가로 settings.py에 
    # Custom User
    AUTH_USER_MODEL = 'users.User' 추가해줘야 한다.

# admin.py에 모델을 등록하는 방법
    @admin.register(models.User)
    class CustomUserAdmin(UserAdmin):
        pass

# 장고 기본 관리자페이지의 사용자어드민 기능을 가져오려면
  UserAdmin을 상속 받아서 사용한다.
  from django.contrib.auth.admin import UserAdmin

# requirements.txt 는 해당 프로젝트를 위해 필요한 것들을 작성한다.
  나중에 pip install -r requirements.txt 로 한 번에 설치가 가능하다.

# gitHub / Git 을 통한 소스관리를 한다면 .gitignore 에 소스를 업로드 하지 않을것들을
  추가하여 관리한다.

# 우린 Class들을 가지고 있고, 그 Class들을 print 하려고 하면 못생겼어.
  우리가 원한다면 저 Class 들이 어떤 식으로 생길지 설정할 수 있어.

# blank = True 는 from에서 필드가 필수적이지 않게 해준다.

# null = True 는 데이터베이스에서 필드가 null 값을 가질 수 있게해준다. 

# Many to One / One to Many : 이 둘은 거의 비슷한데 어느 것에서부터 보느냐에 따라 다르다.
  [Room1, Room2, Room3] => User1
  User1 => [Room1, Room2, Room3]
  
# Many to Many
  [Amenity1, Amenity2, Amenity3] => [Room1, Room2, Room3]
  하나의 room은 하나의 owner만 가질 수 있었는데, 이 경우에는
  하나의 room이 여러 amenity를 가질 수 있다.  
  그리고 여러 amenity 들이 여러 room에서 사용할 수 있다.

# One to One
  한쪽의 하나와 다른쪽의 하나가 연결이 되어있다면 다른것은 연결할 수 없다는 의미.

# auto_now : Object가 저장될 때마다 해당 필드를 현재 date로 설정.

# auto_now_add : Django에 의해 처음 생성되었을 때 채워질 것이다. 

# 파이썬에는 dir() 이라는 내장 함수가 있는데, 어떤 객체를 인자로 넣어주면 해당 객체가 어떤 변수와 메소드를 가지고 있는지 나열해준다.

# 가장 최악의 방법
  from django.http import JsonResponse
  from django.core import serializers
  from django.shortcuts import render
  from .models import Category

  def categories(request):
      all_categories = Category.objects.all()
      return JsonResponse({ 
          "ok": True,
          "categories": serializers.serialize("json", all_categories),   
      })
  장고의 serialization 프레임워크는 우리에게 커스마이징을 위한 많은 기능을 제공하지 않는다.
  그래서 Django REST 프레임워크를 사용할 것이다.

# Django REST framework 엄청나게 강력한 패키지라서 우리의 시간을 많이 절약할 수 있다.
  많은 숏컷을 제공해줘서, REST API를 단시간에 만들 수 있게 해줄것이다.
  Django REST framework는 나온지 오래되었으며, 이미 산업계의 표준이다.

# django rest framework 설치
  pip install djangorestframework
  settings.py에 INSTALLED_APPS에 'rest_framework' 추가한다.

# 새 room을 만드려면 인증이 되어야 한다. 그리고 내가 host 이어야 한다.
  새로운 room을 만들 때 그 room이 어떤 카티고리인지도 알려줘야 한다.
  어떤 amenity를 가지고 있는지도 알려줘야 한다.
  그래서 우리는 serializer 간에 관계(relationship)을 어떻게 만드는지 배워야 한다.
  model 간에 관계를 만든 것처럼 말이야.

# 너가 room을 수정하고 싶을 경우, amenity를 하나 더 추가하거나 카테고리를 바꾸는 것처럼 room을 수정하고 싶을 때
  우리는 이렇게 관계가 있는 걸 어떻게 수정해야하는지 배워야 한다.
  당연히 주인이 아니면 room을 지우지 못하게 해야하기 때문에, 확인을 해야한다.

# serializer.py에서 클래스안의 Meta 안에다가 depth = 1 을 하게되면 관계가 확장이된다.
  예를 들어서 owner의 경우에는 확장되서 기존에는 owner의 id만 json으로 확인할 수 있었는데
  확장이 되면서 owner의 모든 정보를 확인할 수 있다.

# 하지만 문제점은, 대부분의 상황에서는 한 번에 이런 모든 데이터가 필요하지 않다는 것이다.
  우리는 불필요한 정보를 보여주지 않고, 요청하는 데이터의 양에 대해 주의를 해야한다.  
  내가 만들 UI에 따라서 달라진다.

# dept = 1 의 문제점은 커스터마이즈할 수 없다는 것이다. 아무것도 설정할 수 없다.  

# 그래서, 너만의 seralizer를 만들 수 있는 방법을 알려줄게
  serializer를 확장하고 싶은데 모든 걸 다 보여주고 싶지 않을 때를 위해서 말이야.

# 우리는 room을 나열할 때 사용하는 작은 seralizer를 만들 거고
  room 하나만 볼 때 사용하는 큰 serializer를 만들거다.
  그리고 어떻게 우리만의 관계성 serializer를 만들고 설정하는 배워볼 것이다.    

# DetailSerializer의 경우에는 확장이 되어있는 상태이고 연결된 모델들에 대해서도
  입력을 해줘야 생성이 가능하다.
  방의 정보에서 owner 를 read_only=True 로 설정을 하게되면 에러가 발생한다.
  owner의 정보가 null 이 되면 않되기 때문이다.
  이런 경우에는. save()를 호출할 때. request.user의 정보를 같이 넘겨주게 되면
  serializer의 def create()를 호출하게 되고 그 안에 validated_data에 자동으로 추가가 되게 된다.
  추가하는 건 무엇이든지 너의 create 메서드에 validated_dat에 추가가 될것이다.
  - user가 비어있는 에러를 해결 관련 설명

# 근데 추가적인 문제는 우리가 amenities, categories 없이 방을 생성하고 있다는 점이다.
  만약 내가 이런걸 보낼 수 있다면?
  "category": 2,
  "amenities": [1, 2, 3],
  그냥 amenities의 id들만 보내준다면 내 create 메서드가 이 id를 가진 amenity 들을
  찾아서 방과 연결시켜주는 거지

# category 와 amenity 를 serializer에서 'read_only = True'를 하였기 때문에
  validation은 없어진 셈이다. 내가 직접 validation을 진행을 해야한다.

# ParseError 에는 에러의 원인을 입력할 수 있다.

# 모든 코드가 성공하거나 아무 것도 성공하지 않기를 원할때 트랜잭션을 사용해야 한다.
  생성했다가 에러가 나서 지우는것은 ID를 낭비하게 되기 때문에 좋지 않다.

# 장고에서는 기본적으로 모든 쿼리는 즉시 데이터베이스에 적용된다.

# from django.db import transaction
  트랜잭션에서 try-except를 사용한다면 transaction은 에러가 난 사시을 알지 못한다. 제거해줘야 한다.

# if + if 와 if + elif 의 차이점
  if + if : 두 개다 실행
  if + elif : if 에서 만족하면 elif에서 실행되지 않음.

# 가끔은, 유저가 요청한 데이터를 계산해서 필드로 만들어야 할 때가 있을거야
  그리고 가끔은 누가 보느냐에 따라 값이 달라지는 필드를 만들어야 할 때도 있을거야.
  지금 하고 싶은 건, 내 serializer에 추가적인 필들를 넣는 거야.
  내 room의 평균 리뷰가 몇인지 알려주는 필드 말이야.

# 네가 만든 function을 호출해서 그 결과를 serializer fiel에 넣는 법을 가르쳐줄게.
  먼저 우리의 코드를 실행하고 그 결과를 field에 입력하고
  그러고 나서 Room 모델의 rating 메서드를 부르고 field에 넣어줄거야.

# 어떻게 하냐면, 일단 필드를 만드는거야. 이름은 뭐라해도 상관없어.
  serializer에 필드를 추가.
  potato = serializers.SerializerMethodField()
  이건 Django REST framewrok에게 뭘 말하냐면
  네가 potato의 값을 계산할 method를 만들 거라고 하는거야.
  그리고 이 부부은 이름이 특정한 모양을 가져야해서 아주 중요하다.
  def get_potato(self, another): --> 이름은 이 같은 형식을 가져야 한다. 'get_이름'
  메서드 이름은, 속성의 이름 앞에 get_을 붙여야 한다.

# another를 출력을 해보면, 그 메서드를 현재 serializing하고 있는 오브젝트와
  함께 호출이 된다.
  potato.메서드() 로 사용.
  "__all__" 이 아닌 fields 로 되어있다면, 해당 potato를 추가해줘야 한다.

# 방을 보고 있는 유저에 따라 필드를 계산하는 방법에 대해 배워보자.

# serializer를 생성할 때, 원한다면 너는 거기에 약간의 context를 줄 수 있어.
  이 context는, 너가 serializer에 외부 세계에 대한 정보를 보내야 할 때 매우 유용할 것이다.
  예를 들면, 내가 지금 하고 싶은 것은, 방 세부정보에서의 get 메소드에서 말야.

# 나는 serializer에서 context 키워드 인자를 사용하고 싶어.
  serializer = RoomDetailSerializer(room, context={})
  내가 원하는 뭐든지 시리얼라이저에 전달할 수 있어.
  그러면, 네가 원하는 메소드 어떤 것이든 시리얼라이저의 context에 접근할 수 있다는 거야.
  물론 그 serializer 안에 있다면 말이지

  예를 들어 네가 save 메소드를 만든다면 혹은 update 메소드를 만든다면 말야. 어떤 것이든.. 혹은 create 메소드도.

  혹은 심지어 get_rating도 가능해.(커스텀 메소드)

# 이 context에 접근하려면, 여기서 self.context라고 적어주면 된다.

# serializer의 역접근자의 경우에는 네가 사용할 serializer를 적어주고 변수는 related_name을 설정한 이름이거나 
  설정하지 않았을 경우에는 이름_set을 해준다.

# 하지만 방에서 역접근자를 사용하여 리뷰를 보여주는 경우 위험에 처하게 될 수 있다.
  방 하나는 수만 개의 리뷰를 가질 수 있기 때문이다. 
  그래서 너의 방을 보여줄 때, 역접근자를 포함하는 건 좋은 생각이 아니다.
  완전 잘못되어 버릴 수도 있거든.

# 역 접근자를 위해선 일종의 pagination이 있어야 할거야.
  우린 여전히, 특정한 방에 달린 리뷰들을 보고 싶지만 한번에 모든 리뷰들을 로드하고 싶진 않겠지 

# 그래서 다음 영상에서 ID가 1인 방 만의 리뷰를 보기 위한 새로운 URL을 만들거야.

